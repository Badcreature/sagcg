#include "StdAfx.h"
#include "Game/Game.h"
#include "GSAlexGame.h"

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructor
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
GSAlexGame::GSAlexGame()
{
	Logs::debug ( "GSAlexGame\n" );
	m_isGame = Game::getInstance();
	m_isEventManager = & ( EventManager::getInstance() );
	m_isStateMachine = & ( StateMachine::getInstance() );
	casenum=1;
	needstartnew=0;
	camera=0;
	crazyskymesh1=0;
	crazyskymesh2=0;
}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Destructor
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
GSAlexGame::~GSAlexGame()
{
	Logs::debug ( "~GSAlexGame\n" );
}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// State CTOR (when added to the StateMachine stack)
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void GSAlexGame::ctor	( const StateMachine *sm )
{
	Logs::debug ( "State GSAlexGame::ctor\n" );
	camera =
	    m_isGame->getSceneManager()->addCameraSceneNodeFPS();
	camera->setFarValue ( 42000.0f );
	camera->setPosition ( core::vector3df ( 10.121006,414.412659,57.399345 ) );
	camera->setTarget ( core::vector3df ( 10.121006,-414.412659,57.399345 ) );
	//X 10.121006 Y 414.412659 Z 57.399345
	//X -10.153351 Y 69.904083 Z -466.993225
	//X 23.047531 Y 74.711319 Z 656.121948
	crazyskymesh1 = m_isGame->getSceneManager()->addAnimatedMeshSceneNode ( m_isGame->getSceneManager()->getMesh ( "data/alexgame/shape3d.3ds" ) );
	crazyskymesh1->setMaterialTexture ( 0,m_isGame->getVideoDriver()->getTexture ( "data/alexgame/red1.jpg" ) );
	crazyskymesh1->setMaterialFlag ( EMF_LIGHTING, false );
	crazyskymesh1->setPosition ( core::vector3df ( 0,70,400 ) );
	crazyskymesh2 = m_isGame->getSceneManager()->addAnimatedMeshSceneNode ( m_isGame->getSceneManager()->getMesh ( "data/alexgame/shape3d.3ds" ) );
	crazyskymesh2->setMaterialTexture ( 0,m_isGame->getVideoDriver()->getTexture ( "data/alexgame/green1.jpg" ) );
	crazyskymesh2->setMaterialFlag ( EMF_LIGHTING, false );
	crazyskymesh2->setPosition ( core::vector3df ( 0,70,400 ) );
	scene::ISceneNode  *stol = m_isGame->getSceneManager()->addAnimatedMeshSceneNode ( m_isGame->getSceneManager()->getMesh ( "data/alexgame/stol3d.3ds" ) );
	stol->setMaterialTexture ( 0,m_isGame->getVideoDriver()->getTexture ( "data/alexgame/stol.jpg" ) );
	stol->setMaterialFlag ( EMF_LIGHTING, false );
	stol->setPosition ( core::vector3df ( 0,0,0 ) );
	//camera->setRotation(stol->getRotation());
}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// State DTOR (when removed from the StateMachine stack)
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void GSAlexGame::dtor	( const StateMachine *sm )
{
	Logs::debug ( "State GSAlexGame::dtor\n" );
}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// State update (game update: update)
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void GSAlexGame::update ( StateMachine *sm )
{
	int deltatime=sm->getTimeStamp();
	Logs::debug ( "State GSAlexGame::update\n" );
	printf ( "X %f Y %f Z %f \n",camera->getPosition().X,camera->getPosition().Y,camera->getPosition().Z );

	if ( needstartnew )
	{
		casenum=rand() %2;
		needstartnew=false;
	}

	switch ( casenum )
	{
		case 0:
			if ( crazyskymesh2->getPosition().Z>400 || crazyskymesh2->getPosition().Z<-400 )
			{
				crazyskymesh2->setPosition ( core::vector3df ( crazyskymesh2->getPosition().X,crazyskymesh2->getPosition().Y,-400 ) );
				needstartnew=true;
			}

			else
			{
				crazyskymesh2->setPosition ( core::vector3df ( crazyskymesh2->getPosition().X,crazyskymesh2->getPosition().Y,crazyskymesh2->getPosition().Z+15 ) );
			}

			break;

		case 1:
			if ( crazyskymesh1->getPosition().Z>400 || crazyskymesh1->getPosition().Z<-400 )
			{
				crazyskymesh1->setPosition ( core::vector3df ( crazyskymesh1->getPosition().X,crazyskymesh1->getPosition().Y,-400 ) );
				needstartnew=true;
			}

			else
			{
				crazyskymesh1->setPosition ( core::vector3df ( crazyskymesh1->getPosition().X,crazyskymesh1->getPosition().Y,crazyskymesh1->getPosition().Z+15 ) );
			}

			break;
	}
}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// State pause (when a new state is added atop)
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void GSAlexGame::pause	( const StateMachine *sm )
{
	Logs::debug ( "State GSAlexGame::pause\n" );
}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// State resume (when the state above is removed)
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void GSAlexGame::resume	( const StateMachine *sm )
{
	Logs::debug ( "State GSAlexGame::resume\n" );
}


// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// State draw (game update: draw)
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void GSAlexGame::draw	( const StateMachine *sm )
{
	Logs::debug ( "State GSAlexGame::draw\n" );
}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// State draw2d (draw 2d elements in front)
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void GSAlexGame::draw2d	( const StateMachine *sm )
{
	Logs::debug ( "State GSAlexGame::draw2d\n" );
}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// State sleep (application is interrupted)
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void GSAlexGame::sleep	( const StateMachine *sm )
{
	Logs::debug ( "State GSAlexGame::sleep\n" );
}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// State wakeup (application is resumed)
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void GSAlexGame::wakeup	( const StateMachine *sm )
{
	Logs::debug ( "State GSAlexGame::wakeup\n" );
}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Configuration state (If this option is true the state Update and Draw(draw2d) regardless of pause)
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
bool GSAlexGame::isWorkingInParallel()
{
return true;
}
*/

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Configuration state (If this option is true the state Loding screen Disable. )
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
bool GSAlexGame::isLoadingDisable()
{
return true;
}
*/


// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// EReceiver
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void	GSAlexGame::onEvent ( const EEvent *ev, const EventManager *evMgr )
{
	Logs::debug ( "State GSAlexGame onEvent\n" );
}



