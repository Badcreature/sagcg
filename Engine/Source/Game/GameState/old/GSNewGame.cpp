#include "StdAfx.h"
#include "Game/Game.h"
#include "GSNewGame.h"
#include "Game/tool/Camera3rdPerson.h"
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructor
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
GSNewGame::GSNewGame()
{
	Logs::debug ( "GSNewGame\n" );
	m_isGame = Game::getInstance();
	m_isEventManager = & ( EventManager::getInstance() );
	m_isStateMachine = & ( StateMachine::getInstance() );
}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Destructor
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
GSNewGame::~GSNewGame()
{
	Logs::debug ( "~GSNewGame\n" );
}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// State CTOR (when added to the StateMachine stack)
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void GSNewGame::ctor	( const StateMachine *sm )
{
	Logs::debug ( "State GSNewGame::ctor\n" );
	m_isGame->getIrrlichtDevice()->getFileSystem()->addZipFileArchive ( "data/NewGameNullmap.pxd" );
	scene::IAnimatedMesh *mesh = m_isGame->getSceneManager()->getMesh ( "NewGameNullmap.bsp" );
	//
	scene::ICameraSceneNode *cam=m_isGame->getSceneManager()->addCameraSceneNodeFPS ( 0, 100.0f, .3f, 1, 0, 0, true, 3.f );
	//	scene::ICameraSceneNode *cam=m_isGame->getSceneManager()->addCameraSceneNode ();
	cam->setFarValue ( 1000000.0 );
	/////////////
	scene::IMeshSceneNode *q3node = 0;

	if ( mesh )
	{
		q3node = m_isGame->getSceneManager()->addOctreeSceneNode ( mesh->getMesh ( 0 ), 0, 1 );
	}

	scene::ITriangleSelector *selector = 0;
	selector = m_isGame->getSceneManager()->createOctreeTriangleSelector ( q3node->getMesh(), q3node, 128 );
	q3node->setTriangleSelector ( selector );
	scene::ISceneNodeAnimator *anim = m_isGame->getSceneManager()->createCollisionResponseAnimator (
	                                      selector, cam, core::vector3df ( 30,90,30 ),
	                                      core::vector3df ( 0,-10,0 ), core::vector3df ( 0,30,0 ) );
	selector->drop();
	cam->addAnimator ( anim );
	anim->drop();
}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// State DTOR (when removed from the StateMachine stack)
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void GSNewGame::dtor	( const StateMachine *sm )
{
	Logs::debug ( "State GSNewGame::dtor\n" );
}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// State update (game update: update)
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void GSNewGame::update ( StateMachine *sm )
{
	Logs::debug ( "State GSNewGame::update\n" );
}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// State pause (when a new state is added atop)
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void GSNewGame::pause	( const StateMachine *sm )
{
	Logs::debug ( "State GSNewGame::pause\n" );
}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// State resume (when the state above is removed)
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void GSNewGame::resume	( const StateMachine *sm )
{
	Logs::debug ( "State GSNewGame::resume\n" );
}


// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// State draw (game update: draw)
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void GSNewGame::draw	( const StateMachine *sm )
{
	Logs::debug ( "State GSNewGame::draw\n" );
}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// State draw2d (draw 2d elements in front)
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void GSNewGame::draw2d	( const StateMachine *sm )
{
	Logs::debug ( "State GSNewGame::draw2d\n" );
}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// State sleep (application is interrupted)
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void GSNewGame::sleep	( const StateMachine *sm )
{
	Logs::debug ( "State GSNewGame::sleep\n" );
}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// State wakeup (application is resumed)
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void GSNewGame::wakeup	( const StateMachine *sm )
{
	Logs::debug ( "State GSNewGame::wakeup\n" );
}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Configuration state (If this option is true the state Update and Draw(draw2d) regardless of pause)
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
bool GSNewGame::isWorkingInParallel()
{
return true;
}
*/

// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Configuration state (If this option is true the state Loding screen Disable. )
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
bool GSNewGame::isLoadingDisable()
{
return true;
}
*/


// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// EReceiver
// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void	GSNewGame::onEvent ( const EEvent *ev, const EventManager *evMgr )
{
	Logs::debug ( "State GSNewGame onEvent\n" );
}



